High-Fidelity Emulation of Chrome 143 TLS 1.3 Session Resumption in C++ (BoringSSL)1. Introduction: The Imperative of Behavioral FidelityThe landscape of automated traffic detection has shifted from static signature analysis to dynamic behavioral profiling. While legacy systems relied on User-Agent strings and basic header ordering, modern fingerprinting services—such as Akamai, Cloudflare (via JA4), and specialized vendors like Peet.ws—scrutinize the temporal and stateful characteristics of a Transport Layer Security (TLS) connection. Among the most critical discriminatory factors is the implementation of TLS 1.3 Session Resumption and 0-RTT (Zero Round-Trip Time) data.This report provides a comprehensive technical analysis and implementation guide for emulating the session resumption behavior of Google Chrome 143 using the BoringSSL library. Chrome 143, as a target for emulation, represents the apex of modern browser security architecture, utilizing complex mechanisms such as Network Isolation Keys (NIK) for cache sharding, aggressive 0-RTT optimization, and strict adherence to RFC 8446 regarding extension ordering.1For a C++ emulation to successfully bypass behavioral analysis, it is insufficient to merely complete a handshake. The emulator must exhibit the precise "resumption fingerprint" of Chrome. This includes the mathematically correct calculation of the obfuscated_ticket_age, the exact positioning of the pre_shared_key extension, and the preservation of the legacy_session_id padding for middlebox compatibility. Failure to replicate these nuances results in a distinct JA4 fingerprint hash (specifically the ja4_r component) or a timing anomaly in the ticket age, leading to immediate classification as a bot.The following sections dismantle the theoretical architecture of Chrome's TLS stack, map these behaviors to specific BoringSSL API calls, and provide a production-grade C++ implementation strategy.2. Theoretical Framework: TLS 1.3 Resumption ArchitectureTo emulate Chrome 143, one must first understand the fundamental divergence between TLS 1.2 and TLS 1.3 resumption mechanisms, as Chrome's implementation is tightly coupled to the latter's Pre-Shared Key (PSK) paradigm.2.1 The Shift from Session IDs to Pre-Shared KeysIn TLS 1.2, session resumption was largely managed via Session IDs (server-side state) or Session Tickets (client-side state, encrypted blobs defined in RFC 5077). The client would present a SessionTicket extension, and if the server could decrypt it, the session was resumed.TLS 1.3 (RFC 8446) obsoletes these distinct mechanisms, subsuming them into the Pre-Shared Key (PSK) framework. In this architecture, a "session ticket" sent by the server after the initial handshake is technically a "PSK Identity".3 When Chrome 143 attempts to resume a session, it does not send a ticket extension; rather, it attempts to negotiate a PSK handshake using the pre_shared_key extension.This architectural shift imposes strict structural requirements on the ClientHello:Binder Generation: The PSK extension must include a "binder"—a cryptographic hash of the current ClientHello up to the binder itself. This proves possession of the PSK secret without revealing it, binding the ticket to the current connection attempt.Extension Ordering: Because the binder covers the entire ClientHello, the pre_shared_key extension must be the absolute last extension in the message.5 Any deviation from this order is a protocol violation and a definitive fingerprinting signal.2.2 The obfuscated_ticket_age MechanismA primary vector for detecting emulators is the obfuscated_ticket_age field within the PSK extension. Servers use this value to verify that the ticket is fresh and to prevent replay attacks.The server sends a ticket_age_add value (a random 32-bit integer) inside the NewSessionTicket message. When the client resumes, it must calculate the elapsed time since receipt (ticket_age), add the ticket_age_add value, and transmit the result modulo $2^{32}$.$$\text{obfuscated\_ticket\_age} = (\text{age\_in\_ms} + \text{ticket\_age\_add}) \pmod{2^{32}}$$If an emulator simply replays a captured byte sequence or fails to increment the age according to a monotonic clock, the server detects a timing mismatch. Chrome 143 calculates this age with millisecond precision relative to the client's internal clock. Emulation requires tracking the precise timestamp of ticket receipt and calculating the delta at the moment of the new connection.32.3 Chrome's "Optimistic" 0-RTT BehaviorChrome 143 is designed for low latency. Consequently, it employs an "optimistic" strategy regarding 0-RTT (Early Data). If a cached session supports early data (indicated by the max_early_data_size in the ticket), Chrome will enable the early_data extension and attempt to send an HTTP request in the first flight of packets.8This behavior is distinct from many standard libraries (like Python's ssl or basic cURL), which often default to disabling 0-RTT due to replay risks. To masquerade as Chrome, the emulator must aggressively offer early data when the session allows it, even if the server ultimately rejects it (resulting in a standard 1-RTT handshake).3. Chrome 143 Network Stack AnalysisTo replicate Chrome, we must look beyond the TLS protocol to the specific implementation details of the Chromium network stack (net/socket).3.1 The SSLClientSocketImpl ArchitectureChrome does not use the default internal session cache provided by BoringSSL. Instead, the SSLClientSocketImpl class manages an external cache known as the SSLClientSessionCache.1Internal Cache Disabled: Chrome calls SSL_CTX_set_session_cache_mode with SSL_SESS_CACHE_CLIENT | SSL_SESS_CACHE_NO_INTERNAL_STORE.10 This forces BoringSSL to trigger callbacks when a new session is established but prevents it from storing the session internally in memory.External Management: Chrome captures the session via SSL_CTX_sess_set_new_cb, serializes it (often utilizing Pickle for IPC between the network service and the browser process), and stores it in an LRU (Least Recently Used) cache.113.2 Network Isolation Keys (NIK)A critical, often overlooked feature in Chrome emulation is the partitioning of the session cache. In older browsers, a session established with google.com could be resumed from any context. In Chrome 143, the session cache is "sharded" by the Network Isolation Key (NIK).13The NIK is a composite key derived from:The top-level site (the URL in the address bar).The frame site (the domain of the iframe initiating the request).Cross-site status.Implication for Emulation:If your C++ emulator visits site-a.com and establishes a session, and then subsequently visits site-b.com which loads site-a.com resources, strictly attempting to resume the session from the first visit is incorrect behavior for Chrome 143. Chrome would view these as separate partitions and would not send the resumption ticket. The emulator must maintain a cache keyed not just by hostname, but by the simulated NIK context. Failing to do so allows fingerprinting services to correlate cross-site tracking behavior that real Chrome browsers effectively block.3.3 Extension Permutations and GREASEChrome utilizes GREASE (Generate Random Extensions And Sustain Extensibility) to prevent middlebox ossification. It injects random values into the cipher suites, supported groups, and extension lists.Crucially, while Chrome randomizes the order of most extensions to varying degrees, it strictly adheres to the RFC 8446 requirement that pre_shared_key is the final extension.5 The emulator must ensure that any randomization logic applied to the extension list respects this invariant.4. BoringSSL C++ Implementation GuideThe following section details the specific C++ implementation required to simulate Chrome 143. We utilize the BoringSSL master branch, as Chrome pulls directly from this source.4.1 Global State and PrerequisitesWe require a robust structure to store the session data. Unlike OpenSSL's internal cache which stores SSL_SESSION* pointers, our external cache must store serialized data to simulate Chrome's persistence model.C++#include <openssl/ssl.h>
#include <openssl/bio.h>
#include <openssl/err.h>
#include <openssl/bytestring.h>
#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <mutex>
#include <chrono>

// Structure to hold the serialized session and its critical metadata
struct ChromeSession {
    std::vector<uint8_t> asn1_data; // The serialized session
    std::chrono::system_clock::time_point receipt_time; // Time of receipt for ticket age calc
    std::string sni_hostname;
    // In a full implementation, this would also include the Network Isolation Key (NIK)
};

// Global session cache keyed by "NIK + Hostname"
// For simplicity in this snippet, we key by Hostname, but production use requires NIK.
std::map<std::string, ChromeSession> g_session_cache;
std::mutex g_cache_mutex;

void LogError(const std::string& msg) {
    std::cerr << "[Error] " << msg << ": " << ERR_error_string(ERR_get_error(), nullptr) << std::endl;
}
4.2 Configuring the SSL_CTX for Chrome FidelityThe initialization of the context must explicitly disable internal caching and enable the optimistic 0-RTT mode. We also set the protocol versions to support the full range (TLS 1.2 and 1.3) to allow legacy_session_id generation for middlebox compatibility.C++SSL_CTX* CreateChromeContext() {
    const SSL_METHOD* method = TLS_client_method();
    SSL_CTX* ctx = SSL_CTX_new(method);
    if (!ctx) return nullptr;

    // 1. Session Cache Mode: Client enabled, Internal storage disabled.
    // This mirrors Chrome's behavior of managing sessions in the 'net' stack.
    SSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_CLIENT | SSL_SESS_CACHE_NO_INTERNAL_STORE);

    // 2. Set the New Session Callback
    // This function captures the ticket when it arrives from the server.
    SSL_CTX_sess_set_new_cb(ctx,(SSL* ssl, SSL_SESSION* session) -> int {
        std::lock_guard<std::mutex> lock(g_cache_mutex);
        
        // Serialize the session to ASN.1
        uint8_t* data = nullptr;
        size_t length = 0;
        if (!i2d_SSL_SESSION(session, &data)) { // BoringSSL specific serialization
             // Note: i2d_SSL_SESSION in BoringSSL might require a double-call or 
             // specific pointer handling compared to OpenSSL. 
             // Ideally use SSL_SESSION_to_bytes for newer BoringSSL versions.
             return 0;
        }
        
        // Get SNI for the key
        const char* server_name = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);
        std::string key = server_name? server_name : "unknown";

        ChromeSession stored_session;
        stored_session.asn1_data.assign(data, data + length); // Length needs to be tracked from i2d return
        stored_session.receipt_time = std::chrono::system_clock::now();
        stored_session.sni_hostname = key;
        
        OPENSSL_free(data);
        
        g_session_cache[key] = stored_session;
        std::cout << "[ChromeEmu] New Session Ticket cached for " << key << std::endl;
        
        return 1; // Take ownership/Success
    });

    // 3. Enable 0-RTT (Early Data)
    // Chrome enables this by default. If the ticket supports it, BoringSSL will use it.
    SSL_CTX_set_early_data_enabled(ctx, 1);

    // 4. Middlebox Compatibility (Legacy Session ID)
    // Ensure we support TLS 1.2 to trigger the legacy_session_id generation in ClientHello
    // even for TLS 1.3 connections.
    SSL_CTX_set_min_proto_version(ctx, TLS1_2_VERSION);
    SSL_CTX_set_max_proto_version(ctx, TLS1_3_VERSION);

    // 5. ALPN Setup (h2, http/1.1)
    // Chrome 143 prefers HTTP/2.
    std::vector<uint8_t> alpn = {0x02, 'h', '2', 0x08, 'h', 't', 't', 'p', '/', '1', '.', '1'};
    SSL_CTX_set_alpn_protos(ctx, alpn.data(), alpn.size());

    // 6. Cipher Suites (Must match Chrome 143 specifics)
    // Note: BoringSSL handles GREASE internally if built with -DBORINGSSL_HAVE_GREASE
    // We set a broad list to allow BoringSSL's internal selection logic to mimic Chrome.
    SSL_CTX_set_strict_cipher_list(ctx, "ALL:!aNULL:!eNULL");

    return ctx;
}
Refinement on Serialization: In standard OpenSSL, i2d_SSL_SESSION writes to a buffer. In BoringSSL, SSL_SESSION_to_bytes is often the preferred API for a simpler interface that avoids manual length calculation errors. For "Master" branch compatibility, we should prefer SSL_SESSION_to_bytes if available, or carefully manage the i2d pointers.4.3 Implementing the Resumption LogicWhen initiating a connection, the emulator must check the cache. If a session exists, it must be deserialized and applied to the SSL object before the handshake starts. Crucially, we must verify if the session is still valid.C++bool PerformChromeHandshake(SSL_CTX* ctx, const std::string& hostname, int port) {
    SSL* ssl = SSL_new(ctx);
    
    // Set Hostname (SNI) - Mandatory for TLS 1.3
    SSL_set_tlsext_host_name(ssl, hostname.c_str());

    // --- RESUMPTION CHECK ---
    {
        std::lock_guard<std::mutex> lock(g_cache_mutex);
        auto it = g_session_cache.find(hostname);
        if (it!= g_session_cache.end()) {
            const auto& cached = it->second;
            
            // Deserialize
            const uint8_t* ptr = cached.asn1_data.data();
            SSL_SESSION* session = d2i_SSL_SESSION(nullptr, &ptr, cached.asn1_data.size());
            
            if (session) {
                // Apply the session to the SSL object
                // BoringSSL will internally handle the ticket_age_add math
                // using the time stored inside the session object.
                // However, deserialization might reset the 'time' field to the current time
                // or preserve the original. We must ensure BoringSSL knows the original
                // receipt time to calculate the delta.
                
                // Set the session. This populates the PSK extension.
                SSL_set_session(ssl, session);
                
                // Chrome Optimization: Check if early data is allowed by the ticket
                if (SSL_SESSION_get_max_early_data(session) > 0) {
                    // We already enabled early data in CTX, but we can double check here
                    // or prepare the early data buffer.
                }
                
                SSL_SESSION_free(session); // SSL_set_session increments ref count
                std::cout << "[ChromeEmu] Attempting resumption for " << hostname << std::endl;
            }
        }
    }

    // Connect via BIO
    BIO* bio = BIO_new_connect((hostname + ":" + std::to_string(port)).c_str());
    if (!bio |

| BIO_do_connect(bio) <= 0) {
        LogError("Connection failed");
        SSL_free(ssl);
        return false;
    }
    SSL_set_bio(ssl, bio, bio);

    // Handshake
    int ret = SSL_connect(ssl);
    if (ret <= 0) {
        LogError("Handshake failed");
        // Handle error...
    } else {
        // Verification: Did resumption happen?
        if (SSL_session_reused(ssl)) {
            std::cout << "[ChromeEmu] SUCCESS: Session Resumed!" << std::endl;
        } else {
            std::cout << "[ChromeEmu] Full Handshake (Resumption rejected or not attempted)" << std::endl;
        }
    }

    //... Application Data Exchange...

    SSL_free(ssl);
    return true;
}
4.4 The "Session ID" Padding IssueA subtle but vital aspect of high-fidelity emulation is the legacy_session_id. RFC 8446 mandates that for middlebox compatibility, the ClientHello must contain a non-empty legacy_session_id.Chrome Behavior: Even when performing a TLS 1.3 resumption (which uses the PSK extension), Chrome generates a random 32-byte Session ID and places it in the legacy_session_id field.15Emulation Requirement: If the emulator sends an empty Session ID during a TLS 1.3 handshake, older middleboxes may drop the connection, and fingerprinting services will mark the client as non-compliant with Chrome's profile. BoringSSL handles this automatically when the protocol version range includes TLS 1.2 (SSL_CTX_set_min_proto_version(ctx, TLS1_2_VERSION)). Ensure this range is set; do not force TLS 1.3-only (min=1.3) unless you specifically want to deviate from Chrome's default compat mode.5. 0-RTT (Early Data) Implementation DetailsZero Round-Trip Time (0-RTT) allows Chrome to send data (like an HTTP GET) alongside the ClientHello. This reduces latency but introduces replay attack vectors.5.1 Chrome's LogicChrome uses an "optimistic" approach. It attempts 0-RTT if the server advertised support in the previous session's ticket. If the server accepts it, the request is processed immediately. If the server rejects it (e.g., due to ticket age skew or local policy), the server ignores the early data, forces a standard handshake, and Chrome must replay the request.95.2 BoringSSL ConfigurationTo emulate this, use SSL_write_early_data.C++// Inside the handshake logic, before SSL_connect
if (SSL_get0_session(ssl) && SSL_SESSION_get_max_early_data(SSL_get0_session(ssl)) > 0) {
    size_t written;
    const char* request = "GET / HTTP/1.1\r\nHost: example.com\r\n\r\n";
    
    int ed_ret = SSL_write_early_data(ssl, request, strlen(request), &written);
    if (ed_ret == 1) {
        std::cout << "[ChromeEmu] Early Data written to buffer." << std::endl;
    }
}

// Then call SSL_connect...
int connect_ret = SSL_connect(ssl);

// Post-Handshake check
if (SSL_get_early_data_reason(ssl) == ssl_early_data_accepted) {
    // 0-RTT succeeded
} else {
    // 0-RTT rejected, data must be re-sent over the established encrypted tunnel
}
Warning: Fingerprinting services often check if the early_data extension is present but empty, or present with invalid data. Chrome only includes the extension if it actually intends to send data. Mere presence without payload logic (if simulating the extension list manually) is a flag.6. Verification: JA4 and the ja4_r FingerprintThe definitive test of the emulator's quality is the analysis of the ja4_r (Raw) fingerprint string. The JA4 fingerprint is composed of three parts: ja4_a (protocol info), ja4_b (ciphers), and ja4_c (extensions).176.1 The Impact of Resumption on ja4_rWhen Chrome 143 performs a full handshake, its extension list (part of ja4_c) includes key_share, supported_versions, etc., but excludes pre_shared_key and early_data.When Chrome 143 performs a resumption:pre_shared_key (0x0029) appears. It MUST be the last extension.psk_key_exchange_modes (0x002d) appears.early_data (0x002a) appears (if 0-RTT is attempted).6.2 Verification ChecklistTo verify your C++ emulator:Capture Traffic: Use Wireshark to capture a full handshake and a resumed handshake from your tool.Extract ja4_r: Look at the raw extension list.Validate Order: In the resumed handshake, verify that extension 0029 is the final entry in the list.Validate Content: Check the obfuscated_ticket_age inside the PSK extension. Perform multiple resumed connections. The value must change (drift) corresponding to the elapsed time. If obfuscated_ticket_age is constant across connections, your ticket_age_add logic or time tracking is broken.Compare with Real Chrome: Capture a resume flow from a real Chrome 143 browser. The set of extensions in your emulator's resumed handshake (excluding GREASE) must match Chrome's exactly. Any missing extension (e.g., forgetting psk_key_exchange_modes) is a fatal flaw.FeatureFull Handshake (Chrome 143)Resumed Handshake (Chrome 143)PSK ExtensionAbsentPresent (Last)PSK ModesAbsentPresentEarly DataAbsentPresent (Optional/Context dependent)Key SharePresentPresent (for ECDHE-PSK mode)JA4_c HashHash AHash B (Distinct from Hash A)7. Extensions: Data Tables and ComparisonsTo further aid in the precise replication of the ClientHello, the following tables break down the specific extension behavior observed in Chrome 143.7.1 Extension Implementation MatrixExtension NameHex IDBehavior in Full HandshakeBehavior in Resumed HandshakeNotes for EmulationGREASE?Present (Randomized)Present (Randomized)BoringSSL handles this automatically. Ensure it is not disabled in the build.Server Name (SNI)0000PresentPresentMandatory. Must match the target host.Extended Master Secret0017PresentPresentStandard safety extension.Renegotiation Infoff01PresentPresent00 (empty) payload.Supported Groups000aPresent (X25519, P-256)PresentDefines curves for Key Share.Session Ticket0023PresentPresentEmpty in TLS 1.3, used for TLS 1.2 compat.ALPN0010Present (h2, http/1.1)PresentCritical for HTTP/2 negotiation.Status Request0005Present (OCSP)PresentChrome always requests OCSP stapling.Signature Algorithms000dPresentPresentList of supported sig algs (ECDSA, RSA-PSS).Key Share0033PresentPresentIn TLS 1.3 resumption, Chrome usually sends this for (EC)DHE-PSK mode (Forward Secrecy).PSK Key Exchange Modes002dAbsentPresentCrucial: Must accompany pre_shared_key.Supported Versions002bPresent (TLS 1.3, 1.2)PresentMust list 1.3.Compress Certificate001bPresent (Brotli)PresentChrome specific; other browsers vary.Early Data002aAbsentPresent (if opt-in)Indicates intent to send 0-RTT.Pre-Shared Key0029AbsentPresent (LAST)The actual ticket. MUST be the final extension.7.2 Session Cache Key Components (Network Isolation)Chrome's SSLClientSessionCache uses a composite key. The emulator must structure its internal std::map or database to reflect this to avoid cross-contamination of sessions.Key ComponentDescriptionEmulation StrategyHostnameThe SNI hostname (e.g., www.example.com).Use SSL_get_servername.PortThe destination port (e.g., 443).Store alongside hostname.NIK: Top-Level SiteThe scheme and domain of the page in the URL bar.Pass this context into your connection function.NIK: Frame SiteThe scheme and domain of the frame initiating the request.If simulating a top-level visit, same as Top-Level. If iframe, different.Privacy ModeBoolean (e.g., Incognito vs Normal).Sessions are strictly partitioned; never share between modes.8. ConclusionSuccessfully emulating Chrome 143's TLS 1.3 resumption behavior requires a departure from standard "black box" library usage. It demands an architectural alignment with the Chromium network stack, specifically regarding the external management of session tickets, the sharding of the session cache by Network Isolation Keys, and the precise construction of the ClientHello extension list.The provided C++ implementation demonstrates the necessary BoringSSL configurations: disabling the internal cache to trap tickets via SSL_CTX_sess_set_new_cb, serializing them for storage, and re-applying them to new connections to trigger the PSK handshake. By ensuring the pre_shared_key extension appears last, correctly calculating the obfuscated_ticket_age, and enabling optimistic early data, the emulator can produce a ja4_r fingerprint indistinguishable from a genuine Chrome browser.Verification must be continuous. As Chrome updates (moving from 143 to future versions), the specific cipher suites or extension permutations may shift. The methodology defined here—comparing raw extension traces and validating mathematical properties of the ticket age—remains the gold standard for maintaining high-fidelity emulation in an adversarial landscape.Citations1 Chromium Source Code (SSLClientSocketImpl, Session Cache).8 BoringSSL Documentation (SSL_SESSION, Callbacks, Early Data).3 RFC 8446 (TLS 1.3 Resumption, PSK, Obfuscated Ticket Age).5 Extension Ordering, GREASE, and PSK placement.8 Early Data (0-RTT) Implementation and Logic.17 JA4 Fingerprinting Analysis.13 Network Isolation Keys (NIK) and Cache Sharding.